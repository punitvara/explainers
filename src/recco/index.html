<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>How Does Instagram Decide What Reels to Show You?</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Figtree:ital,wght@0,300..900;1,300..900&family=Newsreader:ital,opsz,wght@0,6..72,200..800;1,6..72,200..800&display=swap" rel="stylesheet">
  <style>
    :root {
      --serif: "Newsreader", Georgia, serif;
      --sans: "Figtree", system-ui, -apple-system, sans-serif;
      --mono: "JetBrains Mono", "SF Mono", monospace;
      --bg: #FAF9F7;
      --text: #2d2d2d;
      --text-light: #666;
      --brand: #E1306C;
      --brand-purple: #833AB4;
      --brand-orange: #F77737;
      --brand-blue: #405DE6;
      --widget-bg: #F5F5F5;
      --border: #D3D3D3;
      --link: #833AB4;
      --content-width: 700px;
      --layout-width: 900px;
      --content-padding: 45px;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    html {
      font-size: 21px;
      scroll-behavior: smooth;
    }

    body {
      font-family: var(--serif);
      color: var(--text);
      background: var(--bg);
      line-height: 1.55;
      -webkit-font-smoothing: antialiased;
    }

    /* Navigation */
    nav {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      padding: 20px 32px;
      font-family: var(--sans);
    }
    .logo {
      font-weight: 800;
      font-size: 0.8rem;
      text-decoration: none;
      color: var(--text);
      line-height: 1.1;
    }
    .logo-secondary {
      color: var(--brand);
      font-style: italic;
    }

    /* Hero Header */
    .hero {
      position: relative;
      width: 100%;
      margin-bottom: 2rem;
      overflow: hidden;
      border-radius: 12px;
      max-width: var(--layout-width);
      margin-left: auto;
      margin-right: auto;
    }
    .hero__gradient {
      background: linear-gradient(135deg, #833AB4 0%, #E1306C 40%, #F77737 70%, #FCAF45 100%);
      padding: 3rem 2.5rem 2.5rem;
      min-height: 280px;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      position: relative;
    }
    .hero__gradient::before {
      content: '';
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.15);
    }
    .hero__anim {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      pointer-events: none;
    }
    .hero__text {
      position: relative;
      z-index: 2;
    }
    .post-title {
      font-family: var(--sans);
      font-size: 2.6rem;
      font-weight: 800;
      color: #fff;
      line-height: 1.1;
      margin-bottom: 0.5rem;
    }
    .post-subtitle {
      font-family: var(--sans);
      font-size: 1rem;
      font-weight: 400;
      color: rgba(255,255,255,0.9);
      line-height: 1.3;
    }

    /* Nutshell / Summary */
    .nutshell {
      max-width: var(--content-width);
      margin: 0 auto 2rem;
      padding: 0 var(--content-padding);
      font-style: italic;
      color: var(--text-light);
      font-size: 1rem;
      line-height: 1.6;
    }

    /* Divider */
    hr.full-width {
      border: none;
      border-top: 1px solid var(--border);
      margin: 2rem 0;
    }

    /* Table of Contents */
    .toc-wrapper {
      max-width: var(--content-width);
      margin: 0 auto 2rem;
      padding: 0 var(--content-padding);
    }
    .toc h4 {
      font-family: var(--mono);
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      margin-bottom: 0.8rem;
      color: var(--text);
    }
    .toc ol {
      list-style: none;
      counter-reset: toc-counter;
      padding: 0;
    }
    .toc ol li {
      counter-increment: toc-counter;
      margin-bottom: 0.3rem;
      font-family: var(--sans);
      font-size: 0.8rem;
    }
    .toc ol li::before {
      content: counter(toc-counter, upper-roman) ". ";
      font-weight: 600;
      color: var(--text-light);
      display: inline-block;
      width: 2.5rem;
    }
    .toc a {
      color: var(--link);
      text-decoration: none;
      transition: color 0.2s;
    }
    .toc a:hover { text-decoration: underline; }

    /* Article body */
    article { max-width: var(--layout-width); margin: 0 auto; }
    .post-body {
      max-width: var(--content-width);
      margin: 0 auto;
      padding: 0 var(--content-padding);
    }
    .post-body p {
      margin-bottom: 1rem;
    }
    .post-body em {
      font-style: italic;
    }
    .post-body strong {
      font-weight: 700;
    }

    /* Section headings */
    .section-heading {
      display: flex;
      align-items: baseline;
      gap: 1rem;
      max-width: var(--layout-width);
      margin: 3.5rem auto 0;
      padding: 0 32px 0.5rem;
      border-bottom: 1px solid var(--border);
    }
    .section-number {
      font-family: var(--sans);
      font-size: 2.2rem;
      font-weight: 300;
      color: var(--text-light);
      flex-shrink: 0;
      min-width: 80px;
      text-align: right;
      line-height: 1;
      opacity: 0.5;
    }
    .section-heading h2 {
      font-family: var(--sans);
      font-size: 2rem;
      font-weight: 800;
      color: var(--text);
      line-height: 1.1;
    }

    /* Widgets / Interactive demos */
    .widget {
      background: var(--widget-bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1.5rem;
      margin: 1.5rem 0;
      position: relative;
    }
    .widget .caption {
      font-style: italic;
      font-size: 0.8rem;
      color: var(--text-light);
      text-align: center;
      margin-top: 1rem;
      line-height: 1.4;
    }
    .widget svg {
      display: block;
      margin: 0 auto;
      max-width: 100%;
    }

    /* Labels in diagrams */
    .label--small {
      font-family: var(--mono);
      font-size: 0.55rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      fill: var(--text);
    }

    /* Sliders */
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: var(--border);
      outline: none;
      cursor: pointer;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--brand);
      cursor: pointer;
      border: 2px solid #fff;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--brand);
      cursor: pointer;
      border: 2px solid #fff;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }

    /* Control panel */
    .control-panel {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: center;
      padding: 1rem;
      background: rgba(0,0,0,0.03);
      border-radius: 6px;
      margin-top: 1rem;
    }
    .control-panel label {
      font-family: var(--mono);
      font-size: 0.55rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-light);
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
      flex: 1;
      min-width: 120px;
    }
    .control-panel .value-display {
      font-family: var(--mono);
      font-size: 0.6rem;
      color: var(--brand);
      font-weight: 600;
    }

    /* Figures */
    figure {
      margin: 1.5rem 0;
    }
    figcaption {
      font-style: italic;
      font-size: 0.8rem;
      color: var(--text-light);
      text-align: center;
      margin-top: 0.5rem;
      line-height: 1.4;
    }

    /* Sidenote */
    .sidenote {
      border-left: 3px solid var(--brand);
      padding: 0.8rem 1.2rem;
      margin: 1.5rem 0;
      background: rgba(225, 48, 108, 0.04);
      border-radius: 0 6px 6px 0;
      font-size: 0.85rem;
      color: var(--text-light);
    }
    .sidenote p { margin-bottom: 0.5rem; }
    .sidenote p:last-child { margin-bottom: 0; }

    /* Footnotes */
    .footnotes {
      max-width: var(--content-width);
      margin: 3rem auto 2rem;
      padding: 2rem var(--content-padding) 0;
      border-top: 1px solid var(--border);
      font-size: 0.75rem;
      color: var(--text-light);
    }
    .footnotes ol { padding-left: 1.2rem; }
    .footnotes li { margin-bottom: 0.8rem; line-height: 1.5; }
    sup.fn-ref {
      font-size: 0.6em;
      color: var(--link);
      cursor: pointer;
    }

    /* Footer */
    footer {
      background: var(--text);
      color: #fff;
      padding: 3rem 2rem;
      margin-top: 4rem;
      font-family: var(--sans);
      font-size: 0.7rem;
      text-align: center;
    }

    /* Responsive */
    @media (max-width: 768px) {
      html { font-size: 18px; }
      .post-title { font-size: 1.8rem; }
      .section-heading h2 { font-size: 1.5rem; }
      .section-number { font-size: 1.5rem; min-width: 50px; }
      .post-body, .toc-wrapper, .nutshell { padding: 0 20px; }
      .hero__gradient { padding: 2rem 1.5rem; }
    }

    /* Scroll animations */
    .fade-in {
      opacity: 0;
      transform: translateY(20px);
      transition: opacity 0.6s ease, transform 0.6s ease;
    }
    .fade-in.visible {
      opacity: 1;
      transform: translateY(0);
    }
  </style>
</head>
<body>

  <!-- Navigation -->
  <nav>
    <a href="#" class="logo">recsys<br><em class="logo-secondary">.explained</em></a>
  </nav>

  <!-- Hero Header -->
  <header class="hero">
    <div class="hero__gradient">
      <svg class="hero__anim" id="hero-anim" viewBox="0 0 900 280" preserveAspectRatio="xMidYMid slice"></svg>
      <div class="hero__text">
        <h1 class="post-title">How Does Instagram Decide What Reels to Show You?</h1>
        <h2 class="post-subtitle">Two-tower models, real-time personalization, and the engineering behind your endless scroll.</h2>
      </div>
    </div>
  </header>

  <!-- Nutshell Summary -->
  <div class="nutshell">
    The internet's default answer to "how does Instagram pick my Reels?" is "the algorithm." And that's not wrong, but it's not very useful. In this article, we'll peel back the layers of the recommendation system &mdash; from the two-tower retrieval model to real-time personalization &mdash; until you have a working mental model of how billions of candidate videos get whittled down to the handful you see in under 100 milliseconds. By the end, you'll understand enough to predict how your feed would change if you suddenly started watching entirely different content.
  </div>

  <hr class="full-width" style="max-width: 900px; margin-left: auto; margin-right: auto;">

  <!-- Table of Contents -->
  <div class="toc-wrapper">
    <div class="toc">
      <h4>Contents</h4>
      <ol>
        <li><a href="#intro">Introduction</a></li>
        <li><a href="#what-is-recsys">What even IS a recommendation algorithm?</a></li>
        <li><a href="#two-tower">The Two-Tower Model</a></li>
        <li><a href="#signals">How does it learn what you like?</a></li>
        <li><a href="#pipeline">The Retrieval-Ranking Pipeline</a></li>
        <li><a href="#realtime">Real-Time Personalization</a></li>
        <li><a href="#balance">The Balancing Act</a></li>
        <li><a href="#together">Putting It All Together</a></li>
        <li><a href="#bigger-picture">The Bigger Picture</a></li>
      </ol>
    </div>
  </div>

  <!-- Article -->
  <article>
    <!-- Section I: Introduction -->
    <div class="post-body" id="intro">
      <p>Let's start by asking ourselves: what <em>should</em> your Instagram Reels feed look like?</p>

      <p>Think about it. At any given moment, there are hundreds of millions of Reels on Instagram. Some are 15-second dance clips. Some are 90-second cooking tutorials. Some are a golden retriever doing something inexplicably hilarious. And <em>you</em> &mdash; you're one person with one phone and maybe 20 minutes to kill on the train.</p>

      <p>So how does Instagram decide which handful of Reels to show you, out of that ocean of content? And why does it feel so eerily accurate sometimes?</p>

      <p>The answer involves some genuinely clever engineering. At the heart of it is a <em>recommendation system</em> &mdash; a machine learning pipeline that attempts to predict, in real time, which videos you'll find most engaging. It does this using a multi-stage architecture that trades off speed and precision at each step, narrowing billions of candidates to the few dozen you'll actually see.</p>

      <p>In this article, we'll go deep enough that, by the end, you'll have a working mental model of the whole system. You'll understand <em>why</em> your feed shifts when your behavior changes, <em>how</em> the system can respond to a new interest in minutes, and <em>what</em> tradeoffs engineers make to serve recommendations in under 100 milliseconds.</p>

      <div class="sidenote">
        <p><strong>A note on specifics:</strong> Meta hasn't published the complete internal architecture of their Reels recommendation system. What we'll discuss here is grounded in Meta's public engineering blog posts (particularly about Instagram Explore), published research papers, and industry-standard patterns. Where we're simplifying or illustrating, we'll say so. The mental model you'll build is accurate at the conceptual level &mdash; think of it as a very good map, not a satellite photo.</p>
      </div>
    </div>

    <!-- Section II: What even IS a recommendation algorithm? -->
    <div class="section-heading">
      <span class="section-number">I.</span>
      <h2 id="what-is-recsys">What even IS a recommendation algorithm?</h2>
    </div>
    <div class="post-body">
      <p>Before we dive into the specifics, let's build some intuition for the core problem.</p>

      <p>A recommendation algorithm is, at its simplest, a function that takes two inputs &mdash; a <em>user</em> and a <em>set of items</em> &mdash; and returns a ranked list of items that user is most likely to enjoy. That's it. Everything else is engineering to make this function fast, accurate, and scalable.</p>

      <p>But "simple" is doing a lot of heavy lifting there. Consider the scale:</p>

      <p>Instagram has over <strong>2 billion monthly active users</strong>. New Reels are uploaded constantly &mdash; millions per day. If you wanted to score <em>every</em> possible reel for <em>every</em> possible user, you'd need to evaluate something on the order of 2 billion &times; hundreds of millions of scores. That's... not going to happen in real time. Not even close.</p>

      <p>So the first big insight in recommendation systems is: <strong>you can't score everything</strong>. You need to be clever about which items you even <em>consider</em>.</p>

      <p>This is why modern recommendation systems split the problem into stages. Think of it like hiring at a large company: you don't give every applicant on Earth a 5-hour interview. First, you filter by basic criteria (can they code?). Then a phone screen. Then an onsite. Each stage is more expensive but more precise, and operates on a smaller pool of candidates.</p>

      <p>Recommendation systems work the same way. The rough stages look like this:</p>

      <div class="widget fade-in" id="funnel-overview">
        <svg id="funnel-svg" viewBox="0 0 600 340" >
          <!-- Funnel diagram -->
          <defs>
            <linearGradient id="grad-funnel" x1="0" y1="0" x2="1" y2="0">
              <stop offset="0%" stop-color="#833AB4"/>
              <stop offset="100%" stop-color="#E1306C"/>
            </linearGradient>
          </defs>
          <!-- Stage 1: All content -->
          <rect x="50" y="20" width="500" height="55" rx="8" fill="url(#grad-funnel)" opacity="0.15"/>
          <text x="300" y="42" text-anchor="middle" font-family="Figtree, sans-serif" font-size="17" font-weight="700" fill="#833AB4">ALL REELS ON INSTAGRAM</text>
          <text x="300" y="62" text-anchor="middle" font-family="Figtree, sans-serif" font-size="15" fill="#666">Hundreds of millions of videos</text>

          <!-- Arrow -->
          <polygon points="290,82 310,82 300,95" fill="#D3D3D3"/>

          <!-- Stage 2: Candidate retrieval -->
          <rect x="100" y="100" width="400" height="55" rx="8" fill="url(#grad-funnel)" opacity="0.25"/>
          <text x="300" y="122" text-anchor="middle" font-family="Figtree, sans-serif" font-size="17" font-weight="700" fill="#833AB4">CANDIDATE RETRIEVAL</text>
          <text x="300" y="142" text-anchor="middle" font-family="Figtree, sans-serif" font-size="15" fill="#666">~1,000 candidates &bull; ~10ms</text>

          <!-- Arrow -->
          <polygon points="290,162 310,162 300,175" fill="#D3D3D3"/>

          <!-- Stage 3: Ranking -->
          <rect x="160" y="180" width="280" height="55" rx="8" fill="url(#grad-funnel)" opacity="0.4"/>
          <text x="300" y="202" text-anchor="middle" font-family="Figtree, sans-serif" font-size="17" font-weight="700" fill="#833AB4">RANKING</text>
          <text x="300" y="222" text-anchor="middle" font-family="Figtree, sans-serif" font-size="15" fill="#666">~50 scored &bull; ~50ms</text>

          <!-- Arrow -->
          <polygon points="290,242 310,242 300,255" fill="#D3D3D3"/>

          <!-- Stage 4: Final feed -->
          <rect x="220" y="260" width="160" height="55" rx="8" fill="url(#grad-funnel)" opacity="0.7"/>
          <text x="300" y="282" text-anchor="middle" font-family="Figtree, sans-serif" font-size="17" font-weight="700" fill="#fff">YOUR FEED</text>
          <text x="300" y="302" text-anchor="middle" font-family="Figtree, sans-serif" font-size="15" fill="rgba(255,255,255,0.8)">~10 reels shown</text>
        </svg>
        <div class="caption">The recommendation funnel: hundreds of millions of Reels are progressively narrowed to the ~10 you actually see. Each stage trades off speed for precision. The whole process takes under 100ms.</div>
      </div>

      <p>The magic is in <em>how</em> each stage works. The retrieval stage needs to be blazing fast &mdash; it scans millions of items in milliseconds. The ranking stage can afford to be slower and more thoughtful, because it's only looking at ~1,000 candidates.</p>

      <p>But before we dive into those stages, we need to understand the foundation that makes all of this possible: the <em>two-tower model</em>.</p>
    </div>

    <!-- Section III: The Two-Tower Model -->
    <div class="section-heading">
      <span class="section-number">II.</span>
      <h2 id="two-tower">The Two-Tower Model: A Tale of Two Embeddings</h2>
    </div>
    <div class="post-body">
      <p>Here's the central idea, and it's genuinely elegant.</p>

      <p>Instead of trying to score every user-item pair directly (which is impossibly expensive), we do something clever: we learn to represent users and items as <em>vectors</em> &mdash; lists of numbers &mdash; in the same mathematical space. Then, finding a good recommendation becomes as simple as finding which item vectors are <em>closest</em> to the user vector.</p>

      <p>This is the <strong>two-tower model</strong>, and it's the workhorse of modern retrieval systems. Meta has publicly described using it for Instagram Explore, and variations of it are standard across the industry.<sup class="fn-ref">[1]</sup></p>

      <p>It works like this. There are literally two "towers" &mdash; two separate neural networks:</p>

      <p>The <strong>user tower</strong> takes in everything the system knows about you &mdash; your recent watch history, your likes, your demographics, the time of day, what device you're using &mdash; and compresses it all into a single vector. Think of it as a GPS coordinate for your current interests, but in a 128-dimensional space instead of two dimensions.</p>

      <p>The <strong>item tower</strong> does the same thing for each Reel &mdash; it takes in the video's features (topic, creator, audio, engagement stats, age) and compresses them into a vector in the <em>same</em> space.</p>

      <p>The score for a user-item pair is simply the <em>dot product</em> of their vectors. Items whose vectors point in a similar direction to your user vector get high scores. Items pointing elsewhere get low scores.</p>

      <div class="widget fade-in" id="two-tower-widget">
        <svg id="two-tower-svg" viewBox="0 0 600 420" >
          <!-- User Tower (left) -->
          <rect x="30" y="10" width="220" height="30" rx="5" fill="#833AB4" opacity="0.12"/>
          <text x="140" y="30" text-anchor="middle" font-family="Figtree, sans-serif" font-size="15" font-weight="700" fill="#833AB4">USER TOWER</text>

          <!-- User input features -->
          <rect x="50" y="55" width="180" height="22" rx="4" fill="#E8DEF8"/>
          <text x="140" y="70" text-anchor="middle" font-family="Figtree, sans-serif" font-size="13" fill="#5B21B6">Watch history</text>
          <rect x="50" y="82" width="180" height="22" rx="4" fill="#E8DEF8"/>
          <text x="140" y="97" text-anchor="middle" font-family="Figtree, sans-serif" font-size="13" fill="#5B21B6">Likes &amp; saves</text>
          <rect x="50" y="109" width="180" height="22" rx="4" fill="#E8DEF8"/>
          <text x="140" y="124" text-anchor="middle" font-family="Figtree, sans-serif" font-size="13" fill="#5B21B6">Demographics</text>
          <rect x="50" y="136" width="180" height="22" rx="4" fill="#E8DEF8"/>
          <text x="140" y="151" text-anchor="middle" font-family="Figtree, sans-serif" font-size="13" fill="#5B21B6">Time of day &amp; device</text>

          <!-- Neural network layers (user) -->
          <polygon points="90,170 190,170 170,200 110,200" fill="#833AB4" opacity="0.2"/>
          <text x="140" y="190" text-anchor="middle" font-family="Figtree, sans-serif" font-size="12" fill="#5B21B6">Dense layers</text>
          <polygon points="110,205 170,205 160,230 120,230" fill="#833AB4" opacity="0.3"/>
          <text x="140" y="222" text-anchor="middle" font-family="Figtree, sans-serif" font-size="12" fill="#5B21B6">ReLU</text>
          <polygon points="120,235 160,235 150,260 130,260" fill="#833AB4" opacity="0.4"/>
          <text x="140" y="252" text-anchor="middle" font-family="Figtree, sans-serif" font-size="12" fill="#fff">Compress</text>

          <!-- User embedding output -->
          <rect x="110" y="270" width="60" height="28" rx="14" fill="#833AB4"/>
          <text x="140" y="289" text-anchor="middle" font-family="Figtree, sans-serif" font-size="13" font-weight="700" fill="#fff">u&#x20D7;</text>

          <!-- Item Tower (right) -->
          <rect x="350" y="10" width="220" height="30" rx="5" fill="#E1306C" opacity="0.12"/>
          <text x="460" y="30" text-anchor="middle" font-family="Figtree, sans-serif" font-size="15" font-weight="700" fill="#E1306C">ITEM TOWER</text>

          <!-- Item input features -->
          <rect x="370" y="55" width="180" height="22" rx="4" fill="#FCE4EC"/>
          <text x="460" y="70" text-anchor="middle" font-family="Figtree, sans-serif" font-size="13" fill="#C62828">Video topic &amp; content</text>
          <rect x="370" y="82" width="180" height="22" rx="4" fill="#FCE4EC"/>
          <text x="460" y="97" text-anchor="middle" font-family="Figtree, sans-serif" font-size="13" fill="#C62828">Creator info</text>
          <rect x="370" y="109" width="180" height="22" rx="4" fill="#FCE4EC"/>
          <text x="460" y="124" text-anchor="middle" font-family="Figtree, sans-serif" font-size="13" fill="#C62828">Engagement stats</text>
          <rect x="370" y="136" width="180" height="22" rx="4" fill="#FCE4EC"/>
          <text x="460" y="151" text-anchor="middle" font-family="Figtree, sans-serif" font-size="13" fill="#C62828">Audio &amp; hashtags</text>

          <!-- Neural network layers (item) -->
          <polygon points="410,170 510,170 490,200 430,200" fill="#E1306C" opacity="0.2"/>
          <text x="460" y="190" text-anchor="middle" font-family="Figtree, sans-serif" font-size="12" fill="#C62828">Dense layers</text>
          <polygon points="430,205 490,205 480,230 440,230" fill="#E1306C" opacity="0.3"/>
          <text x="460" y="222" text-anchor="middle" font-family="Figtree, sans-serif" font-size="12" fill="#C62828">ReLU</text>
          <polygon points="440,235 480,235 470,260 450,260" fill="#E1306C" opacity="0.4"/>
          <text x="460" y="252" text-anchor="middle" font-family="Figtree, sans-serif" font-size="12" fill="#fff">Compress</text>

          <!-- Item embedding output -->
          <rect x="430" y="270" width="60" height="28" rx="14" fill="#E1306C"/>
          <text x="460" y="289" text-anchor="middle" font-family="Figtree, sans-serif" font-size="13" font-weight="700" fill="#fff">v&#x20D7;</text>

          <!-- Dot product in center -->
          <line x1="170" y1="284" x2="270" y2="340" stroke="#833AB4" stroke-width="1.5" stroke-dasharray="4,4" opacity="0.5"/>
          <line x1="430" y1="284" x2="330" y2="340" stroke="#E1306C" stroke-width="1.5" stroke-dasharray="4,4" opacity="0.5"/>

          <circle cx="300" cy="355" r="30" fill="#F77737" opacity="0.15" stroke="#F77737" stroke-width="1.5"/>
          <text x="300" y="351" text-anchor="middle" font-family="Figtree, sans-serif" font-size="17" font-weight="800" fill="#F77737">u&#x20D7; &middot; v&#x20D7;</text>
          <text x="300" y="370" text-anchor="middle" font-family="Figtree, sans-serif" font-size="12" fill="#F77737">SIMILARITY SCORE</text>

          <!-- Score output -->
          <text x="300" y="410" text-anchor="middle" font-family="Figtree, sans-serif" font-size="15" font-weight="600" fill="#2d2d2d" id="score-label">score = 0.87</text>
        </svg>
        <div class="caption">The two-tower architecture. Each tower independently compresses its inputs into a dense vector. The recommendation score is the dot product of the two vectors &mdash; items "pointing in the same direction" as the user get high scores.</div>
      </div>

      <p>Now here's why this is so clever: because the towers are <em>independent</em>, you can pre-compute all the item embeddings ahead of time. When a user opens Instagram, you only need to run the user tower once (cheap!), and then find the pre-computed item vectors closest to it.</p>

      <p>"Finding the closest vectors" is a well-studied problem called <strong>approximate nearest neighbor (ANN)</strong> search. There are specialized data structures (like HNSW graphs or inverted file indices) that can search through billions of vectors in single-digit milliseconds. This is what makes retrieval so fast.</p>

      <p>But what does it <em>mean</em> for a user vector and an item vector to be "close"? Let's build some intuition with an interactive demo.</p>

      <div class="widget fade-in" id="embedding-widget">
        <svg id="embedding-svg" viewBox="0 0 600 400" >
        </svg>
        <div class="control-panel">
          <label>
            Cooking Interest
            <input type="range" id="interest-cooking" min="0" max="100" value="70">
            <span class="value-display" id="cooking-val">70%</span>
          </label>
          <label>
            Sports Interest
            <input type="range" id="interest-sports" min="0" max="100" value="30">
            <span class="value-display" id="sports-val">30%</span>
          </label>
          <label>
            Comedy Interest
            <input type="range" id="interest-comedy" min="0" max="100" value="50">
            <span class="value-display" id="comedy-val">50%</span>
          </label>
        </div>
        <div class="caption">A 2D simplification of the embedding space. Each dot is a Reel; the large dot is you. Drag the sliders to change your interests and watch which Reels become "closest" to you. In reality, this space has 128+ dimensions, but the principle is the same.</div>
      </div>

      <p>The beauty of embeddings is that they capture <em>nuance</em>. A cooking reel by a comedian might live somewhere between the "cooking" cluster and the "comedy" cluster. A basketball highlight set to trending music might bridge "sports" and "music." The embedding space lets the model capture these overlaps organically.</p>

      <p>And because both users and items live in the same space, a user who watches lots of cooking comedy will have a vector that's naturally close to those hybrid videos. No one had to manually tag "cooking comedy" as a category &mdash; the model learned it from behavior.</p>
    </div>

    <!-- Section IV: How does it learn what you like? -->
    <div class="section-heading">
      <span class="section-number">III.</span>
      <h2 id="signals">How does it learn what you like?</h2>
    </div>
    <div class="post-body">
      <p>We've been talking about "learning" what you like, but how does the model <em>actually</em> know? You never filled out a survey saying "I'm 70% into cooking and 30% into sports." The system has to <em>infer</em> your preferences from your behavior.</p>

      <p>These behavioral signals are called <strong>implicit feedback</strong>, and they're the lifeblood of the recommendation system. Every time you interact with a Reel &mdash; or <em>don't</em> interact &mdash; you're sending a signal:</p>

      <div class="widget fade-in" id="signals-widget">
        <svg id="signals-svg" viewBox="0 0 600 300" >
        </svg>
        <div class="control-panel">
          <label>
            Watch Duration
            <input type="range" id="watch-duration" min="0" max="100" value="50">
            <span class="value-display" id="watch-val">50%</span>
          </label>
          <label>
            Replays
            <input type="range" id="replays" min="0" max="3" value="0">
            <span class="value-display" id="replay-val">0</span>
          </label>
        </div>
        <div class="caption">Illustrative signal weights. Move the sliders to see how different levels of engagement affect the overall engagement score. Watch duration is the strongest signal &mdash; watching a 30-second reel to the end says more than a quick like. Note: these weights are illustrative, not Instagram's actual values.</div>
      </div>

      <p>The key insight is that <strong>watch time is the most informative signal</strong>. A "like" takes a deliberate tap, but watch time captures involuntary interest. If you watched a 30-second reel all the way through and then replayed it, the system learns far more than from a quick like on a video you scrolled past in 2 seconds.</p>

      <p>Other signals include:</p>

      <p>&bull; <strong>Shares</strong> &mdash; sharing a reel to a friend or your story is a very strong positive signal<br>
      &bull; <strong>Saves</strong> &mdash; bookmarking for later suggests lasting value, not just momentary interest<br>
      &bull; <strong>Comments</strong> &mdash; especially positive or substantive ones<br>
      &bull; <strong>Skips</strong> &mdash; scrolling past quickly is a negative signal<br>
      &bull; <strong>"Not interested"</strong> &mdash; the strongest explicit negative signal</p>

      <p>These signals aren't just used for the currently playing reel. They're aggregated into your user profile over time, creating a rich picture of your preferences. Your <em>recent</em> signals are weighted more heavily than old ones &mdash; if you suddenly start watching a lot of travel content after booking a vacation, the system picks up on that shift quickly.</p>

      <p>The model is trained on billions of these interactions. During training, it learns to position user and item embeddings so that the dot product between a user and items they <em>did</em> engage with is high, and the dot product with items they <em>didn't</em> engage with is low. That's the whole training objective, and it's what makes the embedding space meaningful.</p>

      <div class="sidenote">
        <p><strong>Negative sampling:</strong> You might wonder &mdash; how do you train on "items the user didn't engage with"? After all, the user <em>didn't see</em> most Reels. The standard approach is to sample random items as "negatives." If you watched cooking reels all day, a random sports reel is treated as a negative example. Over billions of examples, this works remarkably well. It's simple, but it's one of those elegant tricks that makes the whole thing tractable.</p>
      </div>
    </div>

    <!-- Section V: The Retrieval-Ranking Pipeline -->
    <div class="section-heading">
      <span class="section-number">IV.</span>
      <h2 id="pipeline">The Retrieval-Ranking Pipeline: Speed vs. Quality</h2>
    </div>
    <div class="post-body">
      <p>Now we get to the part that makes systems engineers break out in a cold sweat: <em>latency</em>.</p>

      <p>When you open Instagram and swipe to the Reels tab, you expect content to appear <em>instantly</em>. If it takes even two seconds, it feels broken. So the entire recommendation pipeline &mdash; from "this user just opened the app" to "here are your top 10 Reels" &mdash; needs to complete in under 100 milliseconds. For billions of users. Concurrently.</p>

      <p>This is why the system uses a multi-stage pipeline. Each stage applies more sophisticated (and expensive) logic to a progressively smaller set of candidates. Let's walk through each stage.</p>

      <p><strong>Stage 1: Candidate Generation (Retrieval)</strong></p>

      <p>The first stage's job is simple: from the hundreds of millions of eligible Reels, find roughly 1,000 that are plausibly interesting to this user. It doesn't need to be perfect &mdash; it just needs to not miss the really good ones.</p>

      <p>This is where the two-tower model and ANN search come in. The system computes your user embedding, then performs an approximate nearest neighbor search against a pre-built index of all item embeddings. In practice, multiple retrieval sources run in parallel &mdash; one might focus on "similar to what you've watched recently," another on "popular among users like you," another on "trending right now."</p>

      <p>The whole thing takes roughly 10 milliseconds.</p>

      <p><strong>Stage 2: Pre-ranking (Lightweight Scoring)</strong></p>

      <p>The ~1,000 candidates now get a quick score from a lighter model. This model is more sophisticated than the dot product, but still fast. It might be a simple neural network that takes in both user and item features jointly. Its job is to cut the candidates from ~1,000 to ~150.</p>

      <p>Think of it as a "first read" &mdash; catching the obviously bad candidates that slipped through retrieval.</p>

      <p><strong>Stage 3: Full Ranking</strong></p>

      <p>This is the expensive one. A deep neural network scores each of the ~150 remaining candidates on multiple objectives simultaneously: predicted watch time, probability of like, probability of share, probability of "not interested," and more. Each candidate gets multiple scores that are combined into a final ranking.</p>

      <p>This model is too expensive to run on millions of items &mdash; but for 150 candidates, it's totally feasible. It takes roughly 50 milliseconds.</p>

      <p><strong>Stage 4: Blending &amp; Policy Filters</strong></p>

      <p>The final stage applies business logic. It enforces diversity (don't show 10 cooking reels in a row), freshness (mix in some new content), safety filters (block policy-violating content), and creator fairness (don't over-concentrate exposure). The result: your final feed of ~10-25 Reels, ready to serve.</p>

      <div class="widget fade-in" id="pipeline-widget">
        <svg id="pipeline-svg" viewBox="0 0 600 380" >
        </svg>
        <div class="control-panel">
          <label>
            Number of candidates to retrieve
            <input type="range" id="retrieval-k" min="100" max="5000" value="1000" step="100">
            <span class="value-display" id="retrieval-k-val">1,000</span>
          </label>
        </div>
        <div class="caption">Adjust the number of retrieval candidates to see the speed-quality tradeoff. More candidates means better recall (you're less likely to miss a great reel) but higher latency. In practice, teams carefully tune this parameter.</div>
      </div>

      <div class="sidenote">
        <p><strong>Abstraction vs. reality:</strong> In practice, Meta runs hundreds of models across Instagram's various surfaces. The "ranking model" isn't one model &mdash; it's a cascade of models making different predictions. Meta's engineering blog describes deploying over 1,000 models for Instagram recommendations. We're simplifying into four stages, but the real system has more fine-grained steps and many more parallel paths.</p>
      </div>

      <p>Here's something that might surprise you: the retrieval stage is often the most important to get right. If a great reel never makes it past retrieval, the ranking model never even sees it. You can have the world's best ranking model, but it can only rank what's in front of it. This is why teams invest enormous effort in recall &mdash; the percentage of truly relevant items that make it through the retrieval stage.</p>
    </div>

    <!-- Section VI: Real-Time Personalization -->
    <div class="section-heading">
      <span class="section-number">V.</span>
      <h2 id="realtime">Real-Time Personalization: Your Feed Updates While You Scroll</h2>
    </div>
    <div class="post-body">
      <p>Here's where things get really interesting. The system doesn't just compute your preferences once and call it a day. It <em>adapts</em> to what you're doing right now, in near real-time.</p>

      <p>Imagine you open Instagram at 8am on a Saturday. You're browsing lazily, watching some cooking content. The system serves you more cooking, some travel, some comedy &mdash; a nice mix based on your historical preferences. Standard stuff.</p>

      <p>But then at 8:15, you watch three basketball highlights in a row. Something shifted. Maybe the NBA playoffs just started. The system notices this pattern immediately. Your user features &mdash; specifically your <em>recent interaction sequence</em> &mdash; have changed. The very next batch of recommendations will start blending in more sports content.</p>

      <p>How does this work technically? The key is that user features are split into two categories:</p>

      <p>&bull; <strong>Stable features:</strong> Your age, location, long-term interest profile. These update slowly (daily or weekly).<br>
      &bull; <strong>Real-time features:</strong> Your last 50 interactions, current session context, time since last visit. These update on <em>every scroll</em>.</p>

      <p>The ranking model takes both as input. So even if your long-term profile says "cooking lover," your real-time features screaming "basketball basketball basketball" will shift the output meaningfully.</p>

      <div class="widget fade-in" id="realtime-widget">
        <svg id="realtime-svg" viewBox="0 0 600 320" >
        </svg>
        <div class="control-panel">
          <label>
            Simulate recent watches
            <input type="range" id="session-slider" min="0" max="10" value="0" step="1">
            <span class="value-display" id="session-val">0 sports reels</span>
          </label>
        </div>
        <div class="caption">Simulate watching a burst of sports reels. Watch how the recommendation mix shifts in near real-time as the system incorporates your recent behavior. The baseline profile is "mostly cooking + comedy" but the system adapts quickly.</div>
      </div>

      <p>This real-time adaptation is one of the reasons the system feels "creepy" sometimes. You watch one video about a topic, and suddenly it's everywhere. But there's no dark magic &mdash; the system is simply very responsive to recent signals, especially when they represent a strong deviation from your baseline.</p>

      <p>There's a subtlety here worth noting: the system doesn't literally retrain the model every time you scroll. The model weights are fixed (they're updated through offline training, typically daily or weekly). What changes in real-time are the <em>input features</em>. Your "recent interactions" feature is a rolling window that shifts with every action. The model was already trained to interpret these features, so feeding in fresh data naturally produces fresh outputs.</p>

      <div class="sidenote">
        <p><strong>Feature stores and streaming:</strong> To make real-time features possible, companies like Meta use sophisticated infrastructure &mdash; feature stores that can serve fresh user features with single-digit millisecond latency, event streaming pipelines (think Apache Kafka) that propagate your actions across the system in near real-time, and online feature computation that aggregates your recent behavior on the fly. The ML model itself might be the easy part &mdash; the infrastructure to feed it fresh data at scale is where the real engineering challenge lies.</p>
      </div>
    </div>

    <!-- Section VII: The Balancing Act -->
    <div class="section-heading">
      <span class="section-number">VI.</span>
      <h2 id="balance">The Balancing Act: Beyond Pure Engagement</h2>
    </div>
    <div class="post-body">
      <p>If you optimized <em>purely</em> for engagement &mdash; predicted watch time, likes, shares &mdash; you'd get a pretty dysfunctional feed. The algorithm would learn that rage-bait and clickbait get clicks, that extreme content keeps people watching, and that showing the same narrow content over and over maximizes short-term engagement.</p>

      <p>This is the <strong>filter bubble</strong> problem, and modern recommendation systems actively work to counteract it.</p>

      <p>In practice, the final ranking isn't just "which reel will this user engage with most?" It's a weighted combination of multiple objectives:</p>

      <p>&bull; <strong>Relevance:</strong> Will the user enjoy this content? (The core objective)<br>
      &bull; <strong>Diversity:</strong> Is the feed varied enough? (Don't show 10 cooking reels in a row)<br>
      &bull; <strong>Freshness:</strong> Is there enough new/recent content? (Don't just replay proven hits)<br>
      &bull; <strong>Exploration:</strong> Should we show something new this user hasn't seen before? (How the system discovers your new interests)<br>
      &bull; <strong>Safety:</strong> Does this content comply with community guidelines?<br>
      &bull; <strong>Creator fairness:</strong> Are we giving diverse creators a fair shot at exposure?</p>

      <p>The art of recommendation engineering is tuning these objectives against each other. More diversity means less relevance per-item. More exploration means some "misses." More safety filtering means potentially removing edgy-but-legal content.</p>

      <div class="widget fade-in" id="balance-widget">
        <svg id="balance-svg" viewBox="0 0 600 220" >
        </svg>
        <div class="control-panel">
          <label>
            Relevance
            <input type="range" id="wt-relevance" min="0" max="100" value="60">
            <span class="value-display" id="wt-rel-val">60%</span>
          </label>
          <label>
            Diversity
            <input type="range" id="wt-diversity" min="0" max="100" value="20">
            <span class="value-display" id="wt-div-val">20%</span>
          </label>
          <label>
            Freshness
            <input type="range" id="wt-freshness" min="0" max="100" value="10">
            <span class="value-display" id="wt-fresh-val">10%</span>
          </label>
          <label>
            Exploration
            <input type="range" id="wt-exploration" min="0" max="100" value="10">
            <span class="value-display" id="wt-exp-val">10%</span>
          </label>
        </div>
        <div class="caption">Adjust the objective weights and watch the simulated feed change. Crank relevance to 100% and you get a narrow, repetitive "filter bubble." Add diversity and exploration and the feed becomes broader and more serendipitous &mdash; but occasionally less "perfect."</div>
      </div>

      <p>This multi-objective approach is also why two people with similar watch histories can see quite different feeds. The system is constantly A/B testing different weight configurations, and different users might be in different experimental cohorts.</p>

      <p>The <strong>exploration vs. exploitation</strong> tradeoff is particularly fascinating. "Exploitation" means showing content the system is <em>confident</em> you'll like (based on past behavior). "Exploration" means showing content the system is <em>uncertain</em> about &mdash; probing whether you might enjoy something new. Without exploration, the system can never discover that you secretly love pottery videos if you've never watched one.</p>

      <p>In practice, a small fraction of your feed (maybe 5-10%) is deliberately exploratory. These "exploration slots" are how the algorithm learns and how your feed evolves over time. If you engage with an exploratory reel, the system has learned something new about you and can exploit that knowledge in future sessions.</p>
    </div>

    <!-- Section VIII: Putting It All Together -->
    <div class="section-heading">
      <span class="section-number">VII.</span>
      <h2 id="together">Putting It All Together</h2>
    </div>
    <div class="post-body">
      <p>Let's trace the full journey of a single recommendation request, from the moment you open the Reels tab to the moment the first video starts playing.</p>

      <div class="widget fade-in" id="fullpipeline-widget">
        <svg id="fullpipeline-svg" viewBox="0 0 600 500" >
        </svg>
        <div class="caption">The full recommendation pipeline, from app open to feed served. The entire process takes under 100ms, running across distributed systems handling billions of requests per day.</div>
      </div>

      <p><strong>T+0ms: You open Reels.</strong> The Instagram app sends a request to the recommendation backend. Included: your user ID, device info, current time, and a hash of your recent on-device interactions.</p>

      <p><strong>T+2ms: Feature assembly.</strong> The system fetches your user features from the feature store. Your stable profile (demographics, long-term interests) and real-time features (last 50 interactions, current session) are assembled into a feature vector.</p>

      <p><strong>T+5ms: User embedding.</strong> The user tower of the two-tower model runs on your features, producing a 128-dimensional user embedding vector.</p>

      <p><strong>T+8ms: Candidate retrieval.</strong> Multiple retrieval sources fire in parallel. ANN search finds ~500 candidates from the embedding index. Collaborative filtering adds ~200 "users like you also watched" candidates. A popularity source adds ~100 trending candidates. A social source adds ~200 from people you follow. Total: ~1,000 unique candidates.</p>

      <p><strong>T+15ms: Pre-ranking.</strong> A lightweight model scores the 1,000 candidates and keeps the top 150.</p>

      <p><strong>T+50ms: Full ranking.</strong> The heavy ranking model scores 150 candidates on multiple objectives. Each gets a predicted watch time, P(like), P(share), P(skip), P(not interested), and more. A value model combines these into a single score.</p>

      <p><strong>T+70ms: Blending &amp; policies.</strong> Diversity injection, freshness requirements, safety filters, and creator fairness rules are applied. The final ~25 reels are ordered.</p>

      <p><strong>T+80ms: Response sent.</strong> The ordered list of Reel IDs (plus pre-fetching hints for video CDN) is sent back to the app.</p>

      <p><strong>T+100ms: First frame.</strong> The app starts playing the first Reel. You start watching. And the system starts collecting signals for the next batch.</p>

      <p>That's the whole cycle &mdash; and it repeats every time you've scrolled through most of the current batch and need more content. The system is constantly running, constantly adapting, constantly learning.</p>

      <div class="sidenote">
        <p><strong>The scale is staggering:</strong> Meta serves recommendations to over 2 billion users across multiple surfaces (Feed, Reels, Explore, Stories). At peak load, this means millions of recommendation requests per second, each touching hundreds of models. The infrastructure required to do this reliably, at low latency, while being fault-tolerant, is arguably the hardest part of the whole system. The ML is elegant; the systems engineering is heroic.</p>
      </div>
    </div>

    <!-- Section IX: The Bigger Picture -->
    <div class="section-heading">
      <span class="section-number">VIII.</span>
      <h2 id="bigger-picture">The Bigger Picture: What's Next?</h2>
    </div>
    <div class="post-body">
      <p>The two-tower + retrieval-ranking pipeline we've described is the industry workhorse. But the field is evolving rapidly. Here's what's on the frontier.</p>

      <p><strong>Transformers are coming for recommendations.</strong> The same architecture that powers ChatGPT is being adapted for recommendation. Instead of treating recommendation as "find similar items," transformer-based models treat it as a <em>sequence prediction</em> problem: given a user's history of interactions (watch A, like B, skip C, share D...), predict the next item they'll engage with. This captures richer temporal patterns than the two-tower approach, though it's more expensive at inference time.</p>

      <p><strong>Multi-modal understanding.</strong> Early recommendation systems treated videos as bags of metadata: "cooking," "creator_xyz," "30 seconds." But modern systems increasingly <em>understand</em> the actual content. Vision models analyze what's happening in the video. Audio models understand the soundtrack. NLP models read the captions and comments. This richer understanding lets the system make connections it couldn't before &mdash; like recommending a silent pottery video to someone who watches cooking, because both involve "satisfying, hands-on craftsmanship."</p>

      <p><strong>Generative retrieval.</strong> Rather than searching through a pre-built index, some new approaches let a neural network directly <em>generate</em> item IDs for retrieval. Think of it as the model hallucinating "the ID of the perfect video for this user" rather than searching for it. It's early, but promising for capturing complex, non-obvious matches.</p>

      <p><strong>On-device inference.</strong> Running parts of the model on the phone itself (rather than in the cloud) can improve latency and privacy. Apple has pushed this with its "on-device ML" initiative, and Meta has explored it for lightweight ranking. The challenge is keeping a model on a phone that's both small enough to run fast and good enough to be useful.</p>

      <p><strong>Causal reasoning and long-term value.</strong> Current systems optimize for short-term engagement: will the user watch this reel <em>right now</em>? But the most valuable recommendations might be ones that keep users coming back tomorrow, next week, next month. Modeling this requires causal reasoning (if I show X, will the user return more often?) rather than just correlation (users who watched X also came back). This is an active research frontier.</p>

      <p>The recommendation system that powers your Reels feed is, in many ways, one of the most sophisticated deployed ML systems in the world. It combines deep learning, information retrieval, distributed systems, and real-time data processing, all operating at a scale that would have seemed like science fiction twenty years ago. And yet, from your perspective, it just... works. You open the app, and interesting videos appear.</p>

      <p>Hopefully, the next time that happens, you'll have a better mental model of the extraordinary engineering behind that seamless experience.</p>
    </div>

  <!-- Footnotes -->
  <div class="footnotes">
    <ol>
      <li id="fn1">Meta's engineering blog describes the two-tower model for Instagram Explore: <em>"Scaling Instagram Explore Recommendations System"</em> (August 2023). The exact Reels architecture isn't publicly detailed, but Meta has confirmed using multi-stage retrieval-ranking pipelines across their surfaces. See also: <em>"Journey to 1000 Models: Scaling Instagram's Recommendation System"</em> (May 2025).</li>
      <li id="fn2">Approximate Nearest Neighbor search is an active area of research. Popular approaches include Hierarchical Navigable Small World (HNSW) graphs, product quantization, and locality-sensitive hashing. Meta has published research on FAISS, their open-source library for efficient similarity search at billion-item scale.</li>
      <li id="fn3">The multi-objective optimization approach described here reflects publicly known industry practices. Meta has described using multiple prediction models (P(like), P(watch time), P(share), etc.) whose outputs are combined into a value model. The specific weights and objectives for Reels haven't been published.</li>
    </ol>
  </div>

  <!-- Footer -->
  <footer>
    <p>Built as an interactive explainer. Not affiliated with Meta/Instagram.</p>
  </footer>

  <script>
    // Scroll animation observer
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('visible');
        }
      });
    }, { threshold: 0.1 });

    document.querySelectorAll('.fade-in').forEach(el => observer.observe(el));

    // ===== PIPELINE SPEED-QUALITY DEMO =====
    (function initPipelineDemo() {
      const svg = document.getElementById('pipeline-svg');
      if (!svg) return;
      const ns = 'http://www.w3.org/2000/svg';
      const W = 600, H = 380;

      function draw(k) {
        svg.innerHTML = '';
        const stages = [
          { label: 'ALL REELS', count: '500M+', time: '-', w: 500, color: '#833AB4', opacity: 0.12 },
          { label: 'RETRIEVAL (ANN)', count: k.toLocaleString(), time: Math.round(2 + k * 0.008) + 'ms', w: 100 + (k / 5000) * 300, color: '#833AB4', opacity: 0.22 },
          { label: 'PRE-RANKING', count: Math.round(k * 0.15).toLocaleString(), time: Math.round(5 + k * 0.015) + 'ms', w: 80 + (k / 5000) * 150, color: '#E1306C', opacity: 0.35 },
          { label: 'FULL RANKING', count: Math.round(k * 0.15 * 0.3).toLocaleString(), time: Math.round(30 + k * 0.01) + 'ms', w: 60 + (k / 5000) * 80, color: '#F77737', opacity: 0.55 },
          { label: 'YOUR FEED', count: '~10', time: '-', w: 140, color: '#E1306C', opacity: 0.8 },
        ];

        const totalLatency = stages.reduce((sum, s) => sum + (parseInt(s.time) || 0), 0);

        let y = 10;
        stages.forEach((stage, i) => {
          const x = (W - stage.w) / 2;
          const rect = document.createElementNS(ns, 'rect');
          rect.setAttribute('x', x); rect.setAttribute('y', y);
          rect.setAttribute('width', stage.w); rect.setAttribute('height', 44);
          rect.setAttribute('rx', '6');
          rect.setAttribute('fill', stage.color); rect.setAttribute('opacity', stage.opacity);
          svg.appendChild(rect);

          const t1 = document.createElementNS(ns, 'text');
          t1.setAttribute('x', W / 2); t1.setAttribute('y', y + 18);
          t1.setAttribute('text-anchor', 'middle');
          t1.setAttribute('font-family', 'Figtree, sans-serif');
          t1.setAttribute('font-size', '15'); t1.setAttribute('font-weight', '700');
          t1.setAttribute('fill', i === stages.length - 1 ? '#fff' : stage.color);
          t1.textContent = stage.label;
          svg.appendChild(t1);

          const t2 = document.createElementNS(ns, 'text');
          t2.setAttribute('x', W / 2); t2.setAttribute('y', y + 35);
          t2.setAttribute('text-anchor', 'middle');
          t2.setAttribute('font-family', 'Figtree, sans-serif');
          t2.setAttribute('font-size', '14');
          t2.setAttribute('fill', i === stages.length - 1 ? 'rgba(255,255,255,0.8)' : '#666');
          t2.textContent = stage.count + ' items' + (stage.time !== '-' ? '  ' + stage.time : '');
          svg.appendChild(t2);

          // Time label on right
          if (stage.time !== '-') {
            const tRight = document.createElementNS(ns, 'text');
            tRight.setAttribute('x', x + stage.w + 10); tRight.setAttribute('y', y + 28);
            tRight.setAttribute('font-family', 'Figtree, sans-serif');
            tRight.setAttribute('font-size', '14'); tRight.setAttribute('fill', '#999');
            tRight.textContent = stage.time;
            svg.appendChild(tRight);
          }

          y += 54;
          if (i < stages.length - 1) {
            const arrow = document.createElementNS(ns, 'polygon');
            arrow.setAttribute('points', `${W/2 - 6},${y - 12} ${W/2 + 6},${y - 12} ${W/2},${y - 3}`);
            arrow.setAttribute('fill', '#D3D3D3');
            svg.appendChild(arrow);
          }
        });

        // Total latency bar at bottom
        y += 15;
        const latBar = document.createElementNS(ns, 'rect');
        latBar.setAttribute('x', 100); latBar.setAttribute('y', y);
        latBar.setAttribute('width', Math.min(400, totalLatency * 3)); latBar.setAttribute('height', 8);
        latBar.setAttribute('rx', '4'); latBar.setAttribute('fill', totalLatency > 100 ? '#E1306C' : '#58C322');
        svg.appendChild(latBar);

        const latLabel = document.createElementNS(ns, 'text');
        latLabel.setAttribute('x', W / 2); latLabel.setAttribute('y', y + 28);
        latLabel.setAttribute('text-anchor', 'middle');
        latLabel.setAttribute('font-family', 'Figtree, sans-serif');
        latLabel.setAttribute('font-size', '16'); latLabel.setAttribute('font-weight', '700');
        latLabel.setAttribute('fill', totalLatency > 100 ? '#E1306C' : '#58C322');
        latLabel.textContent = 'Total latency: ~' + totalLatency + 'ms' + (totalLatency > 100 ? '  Too slow!' : ' ');
        svg.appendChild(latLabel);
      }

      const slider = document.getElementById('retrieval-k');
      slider.addEventListener('input', () => {
        const k = parseInt(slider.value);
        document.getElementById('retrieval-k-val').textContent = k.toLocaleString();
        draw(k);
      });
      draw(1000);
    })();

    // ===== REAL-TIME PERSONALIZATION DEMO =====
    (function initRealtimeDemo() {
      const svg = document.getElementById('realtime-svg');
      if (!svg) return;
      const ns = 'http://www.w3.org/2000/svg';
      const W = 600, H = 320;

      const categories = [
        { name: 'Cooking', color: '#F77737', baseWeight: 40 },
        { name: 'Comedy', color: '#833AB4', baseWeight: 30 },
        { name: 'Sports', color: '#405DE6', baseWeight: 5 },
        { name: 'Music', color: '#E1306C', baseWeight: 15 },
        { name: 'Travel', color: '#58C322', baseWeight: 10 },
      ];

      function draw(sportsWatched) {
        svg.innerHTML = '';

        // Calculate weights with sports boost
        const sportsBoost = sportsWatched * 8;
        const dampFactor = 1 / (1 + sportsWatched * 0.15);
        const weights = categories.map(cat => {
          if (cat.name === 'Sports') return cat.baseWeight + sportsBoost;
          return cat.baseWeight * dampFactor;
        });
        const total = weights.reduce((s, w) => s + w, 0);

        // Title
        const title = document.createElementNS(ns, 'text');
        title.setAttribute('x', W / 2); title.setAttribute('y', 25);
        title.setAttribute('text-anchor', 'middle');
        title.setAttribute('font-family', 'Figtree, sans-serif');
        title.setAttribute('font-size', '16'); title.setAttribute('font-weight', '700');
        title.setAttribute('fill', '#2d2d2d');
        title.textContent = 'YOUR RECOMMENDED FEED MIX';
        svg.appendChild(title);

        // Draw horizontal stacked bar
        const barY = 50, barH = 50;
        let x = 50;
        const barW = 500;
        categories.forEach((cat, i) => {
          const pct = weights[i] / total;
          const segW = pct * barW;
          const rect = document.createElementNS(ns, 'rect');
          rect.setAttribute('x', x); rect.setAttribute('y', barY);
          rect.setAttribute('width', Math.max(2, segW)); rect.setAttribute('height', barH);
          rect.setAttribute('fill', cat.color);
          if (i === 0) rect.setAttribute('rx', '6');
          if (i === categories.length - 1) {
            rect.setAttribute('rx', '6');
          }
          rect.style.transition = 'width 0.3s ease, x 0.3s ease';
          svg.appendChild(rect);

          // Label inside bar
          if (segW > 30) {
            const t = document.createElementNS(ns, 'text');
            t.setAttribute('x', x + segW / 2); t.setAttribute('y', barY + barH / 2 + 4);
            t.setAttribute('text-anchor', 'middle');
            t.setAttribute('font-family', 'Figtree, sans-serif');
            t.setAttribute('font-size', '14'); t.setAttribute('font-weight', '600');
            t.setAttribute('fill', '#fff');
            t.textContent = Math.round(pct * 100) + '%';
            svg.appendChild(t);
          }
          x += segW;
        });

        // Legend
        const legendY = 120;
        categories.forEach((cat, i) => {
          const lx = 50 + i * 110;
          const rect = document.createElementNS(ns, 'rect');
          rect.setAttribute('x', lx); rect.setAttribute('y', legendY);
          rect.setAttribute('width', 12); rect.setAttribute('height', 12);
          rect.setAttribute('rx', '2'); rect.setAttribute('fill', cat.color);
          svg.appendChild(rect);

          const t = document.createElementNS(ns, 'text');
          t.setAttribute('x', lx + 18); t.setAttribute('y', legendY + 10);
          t.setAttribute('font-family', 'Figtree, sans-serif');
          t.setAttribute('font-size', '14'); t.setAttribute('fill', '#666');
          t.textContent = cat.name;
          svg.appendChild(t);
        });

        // Timeline visualization
        const tlY = 170;
        const tlTitle = document.createElementNS(ns, 'text');
        tlTitle.setAttribute('x', 50); tlTitle.setAttribute('y', tlY);
        tlTitle.setAttribute('font-family', 'Figtree, sans-serif');
        tlTitle.setAttribute('font-size', '14'); tlTitle.setAttribute('font-weight', '700');
        tlTitle.setAttribute('fill', '#2d2d2d');
        tlTitle.textContent = 'YOUR RECENT WATCHES:';
        svg.appendChild(tlTitle);

        // Draw recent watches as small colored rectangles
        for (let i = 0; i < 10; i++) {
          const wx = 50 + i * 52;
          const wy = tlY + 15;
          const rect = document.createElementNS(ns, 'rect');
          rect.setAttribute('x', wx); rect.setAttribute('y', wy);
          rect.setAttribute('width', 44); rect.setAttribute('height', 65);
          rect.setAttribute('rx', '4');

          let color, label;
          if (i >= 10 - sportsWatched) {
            color = '#405DE6'; label = '';
          } else {
            const cats = ['#F77737', '#833AB4', '#F77737', '#E1306C', '#58C322', '#833AB4', '#F77737', '#58C322', '#833AB4', '#E1306C'];
            const labels = ['', '', '', '', '', '', '', '', '', ''];
            color = cats[i]; label = labels[i];
          }
          rect.setAttribute('fill', color); rect.setAttribute('opacity', '0.2');
          rect.setAttribute('stroke', color); rect.setAttribute('stroke-width', '1.5');
          svg.appendChild(rect);

          const emoji = document.createElementNS(ns, 'text');
          emoji.setAttribute('x', wx + 22); emoji.setAttribute('y', wy + 40);
          emoji.setAttribute('text-anchor', 'middle');
          emoji.setAttribute('font-size', '20');
          emoji.textContent = label;
          svg.appendChild(emoji);
        }
      }

      const slider = document.getElementById('session-slider');
      slider.addEventListener('input', () => {
        const v = parseInt(slider.value);
        document.getElementById('session-val').textContent = v + ' sports reels';
        draw(v);
      });
      draw(0);
    })();

    // ===== BALANCE / MULTI-OBJECTIVE DEMO =====
    (function initBalanceDemo() {
      const svg = document.getElementById('balance-svg');
      if (!svg) return;
      const ns = 'http://www.w3.org/2000/svg';
      const W = 600, H = 320;

      // Seed some reels with properties
      const reels = [];
      const types = [
        { name: '', cat: 'cooking', relevance: 0.9, diversity: 0.2, freshness: 0.3, exploration: 0.1 },
        { name: '', cat: 'cooking', relevance: 0.85, diversity: 0.2, freshness: 0.5, exploration: 0.1 },
        { name: '', cat: 'cooking', relevance: 0.8, diversity: 0.2, freshness: 0.8, exploration: 0.15 },
        { name: '', cat: 'comedy', relevance: 0.7, diversity: 0.5, freshness: 0.4, exploration: 0.2 },
        { name: '', cat: 'comedy', relevance: 0.65, diversity: 0.5, freshness: 0.9, exploration: 0.25 },
        { name: '', cat: 'sports', relevance: 0.3, diversity: 0.8, freshness: 0.6, exploration: 0.7 },
        { name: '', cat: 'music', relevance: 0.5, diversity: 0.7, freshness: 0.7, exploration: 0.5 },
        { name: '', cat: 'travel', relevance: 0.4, diversity: 0.9, freshness: 0.5, exploration: 0.8 },
        { name: '', cat: 'art', relevance: 0.2, diversity: 1.0, freshness: 0.9, exploration: 0.95 },
        { name: '', cat: 'education', relevance: 0.35, diversity: 0.85, freshness: 0.3, exploration: 0.9 },
      ];

      function draw() {
        svg.innerHTML = '';

        const wRel = parseInt(document.getElementById('wt-relevance').value);
        const wDiv = parseInt(document.getElementById('wt-diversity').value);
        const wFresh = parseInt(document.getElementById('wt-freshness').value);
        const wExp = parseInt(document.getElementById('wt-exploration').value);
        const wTotal = wRel + wDiv + wFresh + wExp + 0.01;

        document.getElementById('wt-rel-val').textContent = wRel + '%';
        document.getElementById('wt-div-val').textContent = wDiv + '%';
        document.getElementById('wt-fresh-val').textContent = wFresh + '%';
        document.getElementById('wt-exp-val').textContent = wExp + '%';

        // Score each reel
        const scored = types.map(r => ({
          ...r,
          score: (r.relevance * wRel + r.diversity * wDiv + r.freshness * wFresh + r.exploration * wExp) / wTotal
        }));
        scored.sort((a, b) => b.score - a.score);

        // Title
        const title = document.createElementNS(ns, 'text');
        title.setAttribute('x', W / 2); title.setAttribute('y', 25);
        title.setAttribute('text-anchor', 'middle');
        title.setAttribute('font-family', 'Figtree, sans-serif');
        title.setAttribute('font-size', '16'); title.setAttribute('font-weight', '700');
        title.setAttribute('fill', '#2d2d2d');
        title.textContent = 'SIMULATED FEED (TOP 5)';
        svg.appendChild(title);

        // Draw feed as phone-like cards
        const cardW = 90, cardH = 130, gap = 12;
        const startX = (W - (cardW * 5 + gap * 4)) / 2;

        scored.slice(0, 5).forEach((reel, i) => {
          const x = startX + i * (cardW + gap);
          const y = 45;

          // Card background
          const rect = document.createElementNS(ns, 'rect');
          rect.setAttribute('x', x); rect.setAttribute('y', y);
          rect.setAttribute('width', cardW); rect.setAttribute('height', cardH);
          rect.setAttribute('rx', '8');
          rect.setAttribute('fill', '#fff');
          rect.setAttribute('stroke', '#ddd'); rect.setAttribute('stroke-width', '1');
          svg.appendChild(rect);

          // Emoji
          const emoji = document.createElementNS(ns, 'text');
          emoji.setAttribute('x', x + cardW / 2); emoji.setAttribute('y', y + 55);
          emoji.setAttribute('text-anchor', 'middle');
          emoji.setAttribute('font-size', '32');
          emoji.textContent = reel.name;
          svg.appendChild(emoji);

          // Category label
          const catLabel = document.createElementNS(ns, 'text');
          catLabel.setAttribute('x', x + cardW / 2); catLabel.setAttribute('y', y + 80);
          catLabel.setAttribute('text-anchor', 'middle');
          catLabel.setAttribute('font-family', 'Figtree, sans-serif');
          catLabel.setAttribute('font-size', '13'); catLabel.setAttribute('fill', '#666');
          catLabel.textContent = reel.cat;
          svg.appendChild(catLabel);

          // Score
          const scoreLabel = document.createElementNS(ns, 'text');
          scoreLabel.setAttribute('x', x + cardW / 2); scoreLabel.setAttribute('y', y + 100);
          scoreLabel.setAttribute('text-anchor', 'middle');
          scoreLabel.setAttribute('font-family', 'Figtree, sans-serif');
          scoreLabel.setAttribute('font-size', '14'); scoreLabel.setAttribute('font-weight', '700');
          scoreLabel.setAttribute('fill', '#E1306C');
          scoreLabel.textContent = reel.score.toFixed(2);
          svg.appendChild(scoreLabel);

          // Rank
          const rank = document.createElementNS(ns, 'text');
          rank.setAttribute('x', x + cardW / 2); rank.setAttribute('y', y + 120);
          rank.setAttribute('text-anchor', 'middle');
          rank.setAttribute('font-family', 'Figtree, sans-serif');
          rank.setAttribute('font-size', '12'); rank.setAttribute('fill', '#999');
          rank.textContent = '#' + (i + 1);
          svg.appendChild(rank);
        });

        // Diversity indicator
        const uniqueCats = new Set(scored.slice(0, 5).map(r => r.cat));
        const divScore = uniqueCats.size;
        const divY = 200;
        const divLabel = document.createElementNS(ns, 'text');
        divLabel.setAttribute('x', W / 2); divLabel.setAttribute('y', divY);
        divLabel.setAttribute('text-anchor', 'middle');
        divLabel.setAttribute('font-family', 'Figtree, sans-serif');
        divLabel.setAttribute('font-size', '15');
        divLabel.setAttribute('fill', divScore >= 4 ? '#58C322' : divScore >= 3 ? '#F77737' : '#E1306C');
        divLabel.setAttribute('font-weight', '600');
        divLabel.textContent = `Feed diversity: ${divScore}/5 unique categories` + (divScore <= 2 ? '  Filter bubble!' : divScore >= 4 ? '  Great variety!' : '');
        svg.appendChild(divLabel);
      }

      ['wt-relevance', 'wt-diversity', 'wt-freshness', 'wt-exploration'].forEach(id => {
        document.getElementById(id).addEventListener('input', draw);
      });
      draw();
    })();

    // ===== FULL PIPELINE FLOW DEMO =====
    (function initFullPipelineDemo() {
      const svg = document.getElementById('fullpipeline-svg');
      if (!svg) return;
      const ns = 'http://www.w3.org/2000/svg';
      const W = 600, H = 500;

      const steps = [
        { label: ' App Open', sub: 'Request sent', time: '0ms', color: '#2d2d2d' },
        { label: ' Feature Assembly', sub: 'User profile fetched', time: '2ms', color: '#833AB4' },
        { label: ' User Embedding', sub: '128-dim vector computed', time: '5ms', color: '#833AB4' },
        { label: ' Candidate Retrieval', sub: '~1,000 candidates from multiple sources', time: '8ms', color: '#E1306C' },
        { label: ' Pre-Ranking', sub: 'Cut to ~150 candidates', time: '15ms', color: '#F77737' },
        { label: ' Full Ranking', sub: 'Multi-objective scoring', time: '50ms', color: '#E1306C' },
        { label: ' Blending & Policies', sub: 'Diversity, safety, fairness', time: '70ms', color: '#405DE6' },
        { label: ' Feed Served', sub: '~25 Reels ready', time: '80ms', color: '#58C322' },
      ];

      let y = 20;
      steps.forEach((step, i) => {
        // Timeline dot
        const cx = 50;
        const circle = document.createElementNS(ns, 'circle');
        circle.setAttribute('cx', cx); circle.setAttribute('cy', y + 15);
        circle.setAttribute('r', '8'); circle.setAttribute('fill', step.color);
        svg.appendChild(circle);

        // Connecting line
        if (i < steps.length - 1) {
          const line = document.createElementNS(ns, 'line');
          line.setAttribute('x1', cx); line.setAttribute('y1', y + 23);
          line.setAttribute('x2', cx); line.setAttribute('y2', y + 55);
          line.setAttribute('stroke', '#ddd'); line.setAttribute('stroke-width', '2');
          svg.appendChild(line);
        }

        // Time label
        const timeText = document.createElementNS(ns, 'text');
        timeText.setAttribute('x', cx + 20); timeText.setAttribute('y', y + 12);
        timeText.setAttribute('font-family', 'Figtree, sans-serif');
        timeText.setAttribute('font-size', '14'); timeText.setAttribute('font-weight', '700');
        timeText.setAttribute('fill', step.color);
        timeText.textContent = 'T+' + step.time;
        svg.appendChild(timeText);

        // Label
        const label = document.createElementNS(ns, 'text');
        label.setAttribute('x', cx + 100); label.setAttribute('y', y + 12);
        label.setAttribute('font-family', 'Figtree, sans-serif');
        label.setAttribute('font-size', '17'); label.setAttribute('font-weight', '700');
        label.setAttribute('fill', '#2d2d2d');
        label.textContent = step.label;
        svg.appendChild(label);

        // Sub-label
        const subLabel = document.createElementNS(ns, 'text');
        subLabel.setAttribute('x', cx + 100); subLabel.setAttribute('y', y + 30);
        subLabel.setAttribute('font-family', 'Figtree, sans-serif');
        subLabel.setAttribute('font-size', '14');
        subLabel.setAttribute('fill', '#999');
        subLabel.textContent = step.sub;
        svg.appendChild(subLabel);

        // Progress bar
        const barX = cx + 100;
        const barW = 400;
        const progress = parseInt(step.time) / 80;
        const progBar = document.createElementNS(ns, 'rect');
        progBar.setAttribute('x', barX); progBar.setAttribute('y', y + 37);
        progBar.setAttribute('width', Math.min(barW, progress * barW)); progBar.setAttribute('height', '4');
        progBar.setAttribute('rx', '2'); progBar.setAttribute('fill', step.color);
        progBar.setAttribute('opacity', '0.3');
        svg.appendChild(progBar);

        y += 57;
      });
    })();

    // ===== EMBEDDING SPACE DEMO =====
    (function initEmbeddingDemo() {
      const svg = document.getElementById('embedding-svg');
      if (!svg) return;
      const ns = 'http://www.w3.org/2000/svg';
      const W = 600, H = 400;

      // Generate items in clusters
      const categories = [
        { name: 'Cooking', color: '#F77737', cx: 150, cy: 120 },
        { name: 'Sports', color: '#405DE6', cx: 450, cy: 100 },
        { name: 'Comedy', color: '#833AB4', cx: 300, cy: 300 },
        { name: 'Music', color: '#E1306C', cx: 480, cy: 280 },
        { name: 'Travel', color: '#58C322', cx: 130, cy: 300 },
      ];

      // Background grid
      for (let x = 0; x <= W; x += 50) {
        const line = document.createElementNS(ns, 'line');
        line.setAttribute('x1', x); line.setAttribute('y1', 0);
        line.setAttribute('x2', x); line.setAttribute('y2', H);
        line.setAttribute('stroke', '#e0e0e0'); line.setAttribute('stroke-width', '0.5');
        svg.appendChild(line);
      }
      for (let y = 0; y <= H; y += 50) {
        const line = document.createElementNS(ns, 'line');
        line.setAttribute('x1', 0); line.setAttribute('y1', y);
        line.setAttribute('x2', W); line.setAttribute('y2', y);
        line.setAttribute('stroke', '#e0e0e0'); line.setAttribute('stroke-width', '0.5');
        svg.appendChild(line);
      }

      // Category labels
      categories.forEach(cat => {
        const t = document.createElementNS(ns, 'text');
        t.setAttribute('x', cat.cx); t.setAttribute('y', cat.cy - 45);
        t.setAttribute('text-anchor', 'middle');
        t.setAttribute('font-family', 'Figtree, sans-serif');
        t.setAttribute('font-size', '14'); t.setAttribute('fill', cat.color);
        t.setAttribute('font-weight', '700'); t.setAttribute('opacity', '0.6');
        t.textContent = cat.name.toUpperCase();
        svg.appendChild(t);
      });

      const items = [];
      categories.forEach(cat => {
        for (let i = 0; i < 15; i++) {
          const angle = Math.random() * Math.PI * 2;
          const dist = Math.random() * 40 + 5;
          const x = cat.cx + Math.cos(angle) * dist;
          const y = cat.cy + Math.sin(angle) * dist;
          const c = document.createElementNS(ns, 'circle');
          c.setAttribute('cx', x); c.setAttribute('cy', y);
          c.setAttribute('r', '5'); c.setAttribute('fill', cat.color);
          c.setAttribute('opacity', '0.4');
          c.setAttribute('class', 'item-dot');
          svg.appendChild(c);
          items.push({ el: c, x, y, cat: cat.name, baseCx: cat.cx, baseCy: cat.cy });
        }
      });

      // User dot
      const userDot = document.createElementNS(ns, 'circle');
      userDot.setAttribute('r', '12');
      userDot.setAttribute('fill', '#2d2d2d');
      userDot.setAttribute('stroke', '#fff');
      userDot.setAttribute('stroke-width', '3');
      svg.appendChild(userDot);

      const userLabel = document.createElementNS(ns, 'text');
      userLabel.setAttribute('text-anchor', 'middle');
      userLabel.setAttribute('font-family', 'Figtree, sans-serif');
      userLabel.setAttribute('font-size', '14');
      userLabel.setAttribute('font-weight', '700');
      userLabel.setAttribute('fill', '#2d2d2d');
      userLabel.textContent = 'YOU';
      svg.appendChild(userLabel);

      // Recommendation lines
      const recLines = [];
      for (let i = 0; i < 5; i++) {
        const line = document.createElementNS(ns, 'line');
        line.setAttribute('stroke', '#E1306C');
        line.setAttribute('stroke-width', '1.5');
        line.setAttribute('stroke-dasharray', '3,3');
        line.setAttribute('opacity', '0.6');
        svg.appendChild(line);
        recLines.push(line);
      }

      function updateEmbedding() {
        const cooking = parseInt(document.getElementById('interest-cooking').value);
        const sports = parseInt(document.getElementById('interest-sports').value);
        const comedy = parseInt(document.getElementById('interest-comedy').value);
        document.getElementById('cooking-val').textContent = cooking + '%';
        document.getElementById('sports-val').textContent = sports + '%';
        document.getElementById('comedy-val').textContent = comedy + '%';

        // Position user based on weighted average of category centers
        const total = cooking + sports + comedy + 0.01;
        const ux = (categories[0].cx * cooking + categories[1].cx * sports + categories[2].cx * comedy) / total;
        const uy = (categories[0].cy * cooking + categories[1].cy * sports + categories[2].cy * comedy) / total;

        userDot.setAttribute('cx', ux);
        userDot.setAttribute('cy', uy);
        userLabel.setAttribute('x', ux);
        userLabel.setAttribute('y', uy - 18);

        // Score items by distance
        items.forEach(item => {
          const dx = item.x - ux;
          const dy = item.y - uy;
          const dist = Math.sqrt(dx * dx + dy * dy);
          item.dist = dist;
          const maxDist = 300;
          const opacity = Math.max(0.15, 1 - dist / maxDist);
          const r = dist < 60 ? 7 : 5;
          item.el.setAttribute('opacity', opacity);
          item.el.setAttribute('r', r);
        });

        // Top 5 nearest
        const sorted = [...items].sort((a, b) => a.dist - b.dist);
        for (let i = 0; i < 5; i++) {
          recLines[i].setAttribute('x1', ux);
          recLines[i].setAttribute('y1', uy);
          recLines[i].setAttribute('x2', sorted[i].x);
          recLines[i].setAttribute('y2', sorted[i].y);
          sorted[i].el.setAttribute('r', '9');
          sorted[i].el.setAttribute('opacity', '1');
          sorted[i].el.setAttribute('stroke', '#2d2d2d');
          sorted[i].el.setAttribute('stroke-width', '2');
        }
        // Reset non-top items stroke
        items.forEach(item => {
          if (!sorted.slice(0, 5).includes(item)) {
            item.el.removeAttribute('stroke');
            item.el.removeAttribute('stroke-width');
          }
        });
      }

      document.getElementById('interest-cooking').addEventListener('input', updateEmbedding);
      document.getElementById('interest-sports').addEventListener('input', updateEmbedding);
      document.getElementById('interest-comedy').addEventListener('input', updateEmbedding);
      updateEmbedding();
    })();

    // ===== SIGNALS DEMO =====
    (function initSignalsDemo() {
      const svg = document.getElementById('signals-svg');
      if (!svg) return;
      const ns = 'http://www.w3.org/2000/svg';

      const signals = [
        { name: 'Watch Time', y: 40, weight: 1.0, color: '#E1306C' },
        { name: 'Replay', y: 85, weight: 0.8, color: '#833AB4' },
        { name: 'Share', y: 130, weight: 0.6, color: '#F77737' },
        { name: 'Save', y: 175, weight: 0.5, color: '#405DE6' },
        { name: 'Like', y: 220, weight: 0.3, color: '#58C322' },
        { name: 'Comment', y: 265, weight: 0.25, color: '#00BCD4' },
      ];

      const barStartX = 160;
      const maxBarW = 350;

      // Labels and bars
      const bars = [];
      signals.forEach(sig => {
        const label = document.createElementNS(ns, 'text');
        label.setAttribute('x', barStartX - 10);
        label.setAttribute('y', sig.y + 4);
        label.setAttribute('text-anchor', 'end');
        label.setAttribute('font-family', 'Figtree, sans-serif');
        label.setAttribute('font-size', '15');
        label.setAttribute('fill', '#2d2d2d');
        label.setAttribute('font-weight', '600');
        label.textContent = sig.name;
        svg.appendChild(label);

        // Background bar
        const bgBar = document.createElementNS(ns, 'rect');
        bgBar.setAttribute('x', barStartX);
        bgBar.setAttribute('y', sig.y - 10);
        bgBar.setAttribute('width', maxBarW);
        bgBar.setAttribute('height', 20);
        bgBar.setAttribute('rx', '4');
        bgBar.setAttribute('fill', '#eee');
        svg.appendChild(bgBar);

        // Active bar
        const bar = document.createElementNS(ns, 'rect');
        bar.setAttribute('x', barStartX);
        bar.setAttribute('y', sig.y - 10);
        bar.setAttribute('height', 20);
        bar.setAttribute('rx', '4');
        bar.setAttribute('fill', sig.color);
        bar.setAttribute('opacity', '0.8');
        bar.style.transition = 'width 0.3s ease';
        svg.appendChild(bar);

        // Value text
        const valText = document.createElementNS(ns, 'text');
        valText.setAttribute('y', sig.y + 4);
        valText.setAttribute('font-family', 'Figtree, sans-serif');
        valText.setAttribute('font-size', '13');
        valText.setAttribute('fill', '#fff');
        valText.setAttribute('font-weight', '700');
        svg.appendChild(valText);

        bars.push({ bar, valText, sig });
      });

      // Overall score
      const scoreBg = document.createElementNS(ns, 'rect');
      scoreBg.setAttribute('x', barStartX); scoreBg.setAttribute('y', 285);
      scoreBg.setAttribute('width', maxBarW); scoreBg.setAttribute('height', 4);
      scoreBg.setAttribute('rx', '2'); scoreBg.setAttribute('fill', '#ddd');
      svg.appendChild(scoreBg);

      const scoreLabel = document.createElementNS(ns, 'text');
      scoreLabel.setAttribute('x', barStartX - 10); scoreLabel.setAttribute('y', 292);
      scoreLabel.setAttribute('text-anchor', 'end');
      scoreLabel.setAttribute('font-family', 'Figtree, sans-serif');
      scoreLabel.setAttribute('font-size', '16'); scoreLabel.setAttribute('font-weight', '800');
      scoreLabel.setAttribute('fill', '#2d2d2d');
      scoreLabel.textContent = 'SCORE';
      svg.appendChild(scoreLabel);

      const scoreVal = document.createElementNS(ns, 'text');
      scoreVal.setAttribute('x', barStartX + maxBarW + 10); scoreVal.setAttribute('y', 292);
      scoreVal.setAttribute('font-family', 'Figtree, sans-serif');
      scoreVal.setAttribute('font-size', '18'); scoreVal.setAttribute('font-weight', '800');
      scoreVal.setAttribute('fill', '#E1306C');
      svg.appendChild(scoreVal);

      function updateSignals() {
        const watchPct = parseInt(document.getElementById('watch-duration').value) / 100;
        const replays = parseInt(document.getElementById('replays').value);
        document.getElementById('watch-val').textContent = Math.round(watchPct * 100) + '%';
        document.getElementById('replay-val').textContent = replays;

        const values = [
          watchPct,
          replays / 3,
          watchPct > 0.8 ? 0.4 : 0.1,
          watchPct > 0.6 ? 0.3 : 0.05,
          watchPct > 0.3 ? 0.5 : 0.1,
          watchPct > 0.7 ? 0.2 : 0.05,
        ];

        let totalScore = 0;
        bars.forEach((b, i) => {
          const val = values[i];
          const w = val * maxBarW;
          b.bar.setAttribute('width', Math.max(4, w));
          b.valText.setAttribute('x', barStartX + Math.max(4, w) - 5);
          b.valText.textContent = Math.round(val * 100) + '%';
          if (w < 30) {
            b.valText.setAttribute('x', barStartX + w + 5);
            b.valText.setAttribute('fill', b.sig.color);
          } else {
            b.valText.setAttribute('fill', '#fff');
          }
          totalScore += val * b.sig.weight;
        });

        const normalizedScore = Math.min(1, totalScore / 2.5);
        scoreVal.textContent = normalizedScore.toFixed(2);
      }

      document.getElementById('watch-duration').addEventListener('input', updateSignals);
      document.getElementById('replays').addEventListener('input', updateSignals);
      updateSignals();
    })();

    // Hero animation: floating reel icons
    (function initHeroAnim() {
      const svg = document.getElementById('hero-anim');
      if (!svg) return;
      const ns = 'http://www.w3.org/2000/svg';
      const icons = [];
      for (let i = 0; i < 25; i++) {
        const g = document.createElementNS(ns, 'g');
        const rect = document.createElementNS(ns, 'rect');
        const x = Math.random() * 860 + 20;
        const y = Math.random() * 240 + 20;
        const size = Math.random() * 24 + 12;
        rect.setAttribute('x', '0');
        rect.setAttribute('y', '0');
        rect.setAttribute('width', size);
        rect.setAttribute('height', size * 1.6);
        rect.setAttribute('rx', '3');
        rect.setAttribute('fill', 'rgba(255,255,255,0.08)');
        rect.setAttribute('stroke', 'rgba(255,255,255,0.15)');
        rect.setAttribute('stroke-width', '0.5');
        g.setAttribute('transform', `translate(${x},${y})`);

        // Play triangle
        const tri = document.createElementNS(ns, 'polygon');
        const cx = size / 2;
        const cy = size * 0.8;
        const ts = size * 0.25;
        tri.setAttribute('points', `${cx - ts},${cy - ts} ${cx - ts},${cy + ts} ${cx + ts},${cy}`);
        tri.setAttribute('fill', 'rgba(255,255,255,0.2)');

        g.appendChild(rect);
        g.appendChild(tri);
        svg.appendChild(g);
        icons.push({ el: g, x, y, speed: Math.random() * 0.3 + 0.1, phase: Math.random() * Math.PI * 2 });
      }

      let frame = 0;
      function animate() {
        frame++;
        icons.forEach(icon => {
          const newY = icon.y + Math.sin(frame * 0.01 + icon.phase) * 8;
          const newX = icon.x + Math.cos(frame * 0.008 + icon.phase) * 4;
          icon.el.setAttribute('transform', `translate(${newX},${newY})`);
        });
        requestAnimationFrame(animate);
      }
      animate();
    })();
  </script>
</body>
</html>
